<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" charset="UTF-8">
    <title>QueUp</title>
    <link href="styles.css" rel="stylesheet">
</head>
<body>
    <nav>
        <div id="navside1"><p id="time">Date/time here</p></div>
        <div id="navcenter">
            <p style="font-size: 40px">QueUp</p>
            <p style="font-size: 28px">Queuing System</p>
        </div>
        <div id="navside2">
            <div id="slider">
                <span class="switchCylinder" role="img" aria-label="theme_switch" onclick="switchTheme()">
                    <span class="switchCircle" id="themeSwitchCircle"></span>
                </span>
            </div>
            <div id="collapse" class="collapsible-in-overlay">
                <div style='display: flex; flex-direction: row;'>
                    <p id="help" class="">‚ùì</p>
                    <p id="gear" class="">‚öôÔ∏è</p>
                </div>
                <div class="collapsible">
                    <button class="btn" id="leaveroom" onclick="returnToOverlay()">Leave room</button>
                    <button class="btn" id="closeroom" onclick="closeRoom()">Close room</button>
                    <button class="btn" id="addroomowners" onclick="modRoomOwners('add')">Add room owners</button>
                    <button class="btn" id="delroomowners" onclick="modRoomOwners('del')">Delete room owners</button>
                    <button class="btn" id="toggleroomlock" onclick="toggleRoomLock('del')">Lock Room</button>
                </div>
            </div>
        </div>
    </nav>
    <div class="container" id="rooms">
        <div id="queueadddiv" class="roomtop" onclick="createQueue()">
            <div id="queueadd" class="queue">
                <p>Add queue</p>
            </div>
        </div>
    </div>
    <div class="queueoverlay">
        <div class="panel" id="createpanel">
            <h1>Create a room</h1>
            <div class="row" id="createroomrow" style="justify-content: center; margin-bottom: 50px">
                <!-- <label for="createroom">Room name:</label> -->
                <input type="text" id="createroom" name="createroom" pattern="[A-Z0-9]{5}" placeholder="üîÑ creates a valid room code." value="">
                <p id="genroom" onclick="generateRandomRoomName()" style="cursor: pointer; font-size: 40px; margin: 0">üîÅ</p>
            </div>
            <input type="button" id="createroombtn" style="cursor: pointer" onclick="createRoom()" value="Create">
        </div>
        <div class="panel">
            <h1>Join a room</h1>
            <div class="row" style="margin-bottom: 50px">
                <!-- <label for="joinroom">Room name:</label> -->
                <input type="text" id="joinroom" name="joinroom" placeholder="Enter your 5-char room ID here." pattern="[A-Z0-9]{5}" value="">
            </div>
            <input type="button" id="joinroombtn" style="cursor: pointer" onclick="joinRoom()" value="Join">
        </div>
    </div>
    <div class="tutorialoverlay">
        <h1 style="text-align: center; font-size: 32px">QueUp Help</h1>
        <p>The QueUp system is designed to give Purdue ECE students and staff the ability to quickly create a queuing room, capable of handling multiple queues, and to be able to customize it to fit your class needs.</p>
        <p>Quick start:</p>
        <ul>
            <li>Generate a room code by clicking the üîÅ button.  (Room codes can only be 5 alphanumeric characters.)</li>
            <li>Click "Create".</li>
            <li>To join a queue, click the "+" button for a specific queue.  To leave a queue, click the button with your username on it.</li>
            <li>Share the room code with anyone who wishes to join the queue.  They must enter the code in the "Join a room" panel.</li>
        </ul>
        <p>Each room also has a description that you can customize to help users ensure they're in the right room. </p> 
        <div class="center"><video autoplay loop src="description.webm"></video></div>
        <p>You can rename the "default-queue" to whatever you wish (checkoff, help, aisle1, etc.), as well as add new queues with their own names as well.  Click the name of the queue to rename it, or click the "Add queue" button to add a new queue.</p>
        <div class="center"><video autoplay loop src="queuename.webm"></video></div>
        <p></p>
        <div class="center"><video autoplay loop src="addqueue.webm"></video></div>
        <p>If you create a room, you are automatically the "owner" for the room, which is what lets you set the room description and add/rename queues.  If you wish to give someone else the same privileges as you, click the ‚öôÔ∏è icon, click "Add room owners", and type in a list of Purdue account usernames, separated by commas.</p>  
        <div class="center"><video autoplay loop src="addowner.webm"></video></div>
        <p>You can also remove owners (including yourself) by clicking the ‚öôÔ∏è icon and clicking "Delete room owners", with the same input requirements.  Be sure to have at least one owner for the room - zero owners are not permitted as the room will be inaccessible.</p>
        <p>Each room will remain open as long is there is some activity for 24 hours, after which it will be deleted.  You can also delete a room manually by clicking the ‚öôÔ∏è icon and clicking "Close Room".</p>
        <p>As a measure of protection, non-owners cannot edit the room description or add/rename queues.</p>
    <script>
        window.username = "--username--";
        window.is_owner = false;  // not a risk if changed manually (maliciously) client-side.
                                  // all authz requests are checked against room owners.
        function fetchAndLimit(url) {
            return new Promise(async (resolve, reject) => {
                try {
                    var resp = await fetch(url);
                    if (resp.status == 412) {   // mod_python can't do 429 for some weird reason, so we'll use PRECONDITION_FAILED
                        alert("You appear to be sending too many requests.  Please slow down.");
                        reject("Too many requests");
                    }
                    if (resp.status == 423) {
                        alert("This room is currently locked.  Ask the owner of the room (typically a TA or course staff) to unlock it.");
                        reject("Room locked");
                    }
                    else if ((resp.status == 403) || (resp.status == 401)) {
                        alert("You are not authorized to perform this action.  Unauthorized requests will be logged.");
                        reject("Unauthorized");
                    }
                    else if (resp.status == 500) {
                        alert("An error occurred on the server.  Please try again.");
                        reject("Server error");
                    }
                    resolve(resp);
                }
                catch(err) {
                    console.log("err", err);
                    reject(err);
                }
            })
        }
        async function closeRoom() {
            if (document.querySelectorAll(".is-self").length > 0) {
                alert("You are still in the room.  Please remove yourself from any queues before leaving.");
                return;
            }
            var c = confirm("Are you sure you want to close the room?  This irreversibly removes all students (if any) and deletes the room itself.");
            if (!c) return;
            try {
                if (!window.is_owner) {
                    alert("You are not authorized to close this room.  Unauthorized requests will be logged.");
                    return;
                }
                var response = await fetchAndLimit('roomd.py?setup=true&action=del&room=' + roomname);
                if (response.status != 200) {
                    alert("An error occurred while deleting the room.  Closing out anyway...");
                    returnToOverlay();
                }
            }
            catch(err) {
                alert("An error occurred on first fetch: " + err.toString());
                console.error(err);
            }
        }
        function returnToOverlay() {
            if (document.querySelectorAll(".is-self").length > 0) {
                alert("You are still in the room.  Please remove yourself from any queues before leaving.");
                return;
            }
            window.evtSource?.close();
            // remove rooms
            Array.from(document.querySelectorAll(".roomtop:not(#queueadddiv)")).forEach(e => e.remove());
            document.getElementById("gear").classList.toggle("opened", false);
            document.querySelector(".collapsible").classList.toggle("opened", false);
            document.getElementById("collapse").classList.toggle("collapsible-in-overlay", true);
            document.getElementById("navside2").classList.toggle("small-screen", false);
            document.getElementsByClassName("queueoverlay")[0].style.display = "flex";
        }
        function generateRandomRoomName() {
            var roomname = "";
            var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
            // do not accept roomname if a character in it occurs more than two times
            while (roomname == "") {
                for (var i = 0; i < 5; i++) {
                    roomname += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                // more than 3 identical chars? try again
                if (roomname.match(/(.)\1{2,}/))
                    roomname = "";
                // must be not all letters and not all numbers
                else if (roomname.match(/^[A-Z]+$/) || roomname.match(/^[0-9]+$/))
                    roomname = "";
            }
            document.getElementById("createroom").value = roomname;
        }
        async function createQueue() {
            var queue = null;
            while (queue == null || !(/^[a-zA-Z0-9]{3,15}$/.test(queue))) {
                var queue = prompt("Enter a valid name for the queue.");
                if ((queue == "") || (queue == null))
                    return;
            }
            try {
                var response = await fetchAndLimit('roomd.py?setup=true&action=add&room=' + roomname + '&queue=' + queue);
                if (response.status != 200) {
                    t = await response.text();
                    alert("An error occurred while creating the queue.  Error: " + t);
                    return;
                }
            }
            catch(err) {
                alert("An error occurred on first fetch: " + err.toString());
                console.error(err);
            }
        }
        async function createRoom() {
            var roomname = document.getElementById("createroom").value;
            if (roomname.length != 5 || !roomname.match(/[A-Z0-9]{5}/)) {
                alert("Room name must be 5 characters long.");
                return;
            }
            try {
                var response = await fetchAndLimit('roomd.py?setup=true&action=add&room=' + roomname);
                console.log(response);
                if (response.status != 200) {
                    alert("An error occurred while creating the room. Error: " + await response.text());
                    return;
                }
                setupRoom(response, roomname);
            }
            catch(err) {
                alert("An error occurred on first data fetch: " + err.toString());
                console.error(err);
            }
        }
        async function joinRoom() {
            document.getElementById("joinroom").value = document.getElementById("joinroom").value.toUpperCase();
            var roomname = document.getElementById("joinroom").value;
            if (roomname.length != 5 || !roomname.match(/[A-Z0-9]{5}/)) {
                alert("Room name must be 5 characters long and contain alphanumeric characters.");
                return;
            }
            try {
                var response = await fetchAndLimit('roomd.py?setup=true&action=chk&room=' + roomname);
                if (response.status != 200) {
                    alert("An error occurred while joining the room.  Please double check the room code.");
                    return;
                }
                setupRoom(response, roomname);
            }
            catch(err) {
                alert("An error occurred on first fetch: " + err.toString());
                console.error(err);
            }
        }
        async function setupRoom(response, roomname) {
            document.getElementById("collapse").classList.toggle("collapsible-in-overlay", false);
            document.getElementById("navside2").classList.toggle("small-screen", true);
            j = await response.text();
            try {
                json = JSON.parse(j);
            }
            catch(err) {
                alert("An error occurred while parsing the response from the server.  Response was: \n" + j);
                return;
            }
            window.is_owner = json["is-owner"];
            var roomsubtitle = (json["subtitle"] === null) ? "" : json["subtitle"];
            window.roomlocked = json["is-locked"];
            console.log(json);
            document.getElementById("queueadddiv").classList.toggle("hide-if-not-owner", !window.is_owner);
            document.getElementById("closeroom").classList.toggle("hide-if-not-owner", !window.is_owner);
            document.getElementById("addroomowners").classList.toggle("hide-if-not-owner", !window.is_owner);
            document.getElementById("delroomowners").classList.toggle("hide-if-not-owner", !window.is_owner);
            document.getElementById("toggleroomlock").classList.toggle("hide-if-not-owner", !window.is_owner);
            if (window.roomlocked == true)
                document.getElementById("toggleroomlock").innerHTML = "Unlock Room";
            else
                document.getElementById("toggleroomlock").innerHTML = "Lock Room";
            addRoom(roomname, roomsubtitle);
            genRoom(roomname, JSON.parse(j));
            window.roomname = roomname;
            createEventSource();
        }
        function createEventSource() {
            if (typeof(EventSource) !== "undefined") {
                window.evtSource = new EventSource("roomd.py?sseupdate=true&room=" + window.roomname);
                window.evtSource.onopen = function() {
                    document.getElementsByClassName("queueoverlay")[0].style.display = "none";
                };
                window.evtSource.onmessage = function(event) {
                    var json = JSON.parse(event.data);
                    // an empty response means the room was deleted. 
                    // close the event source and return to the overlay.
                    console.log(json);
                    if (Object.keys(json).length == 0) {
                        returnToOverlay();
                        return;
                    }
                    else {
                        genRoom(window.roomname, json);
                    }
                    // disableOperations is a hacky way to "rate limit" students from slamming the server
                    // with operations.
                    // this is INTENDED to be coupled with server responding with HTTP 429s to students 
                    // who submit too many requests per second (cannot possibly be more than 3 requests per second).
                    window.disableOperations = false;
                };
                window.evtSource.onerror = () => {
                    if (!window.disableErrors) {
                        window.evtSource.close();
                        alert("An error has occurred awaiting updates from the server.  Please refresh the page.");
                    }
                }
            }
            else {
                alert("This browser does not support Server-Sent Events, which is required to handle room functionality.  Use a more modern browser like Firefox or Chrome.");
            }
        }
        function genRoom(r, json) {
            // json format - { 'room': { 'queue': [username, time] } }
            // so we extract queues by just taking the first key and keying into "json" to get the queues.
            // make sure to sort by longest time created!
            var queues = json[Object.keys(json).filter(e => !["subtitle", "is-owner"].includes(e))[0]];
            // delete queues that don't exist in the JSON
            Array.from(document.querySelectorAll(".queue"))
            .filter(_q => _q.id != "queueadd")                      // must be a real queue - do not remove "Add Queue"!
            .map(_q => _q.id.slice(5))                    // get the queue names
            .filter(_q => _q && !Object.keys(queues).includes(_q)).forEach(_q => {     // queues that are not in the JSON...
                document.querySelector(`#queue${_q}`).remove();     // ...must be removed. start with the queue
                document.querySelector(`[queue=${_q}]`).parentNode.remove(); // and then the title div.
            });
            Object.keys(queues).forEach(_q => {
                if (document.querySelector(`#queue${_q}`) == null) {
                    addQueue(_q);
                }
                var htmlarray = document.querySelector(`#queue${_q}`);
                var list = Array.from(document.querySelector(`#queue${_q}`).children);
                q = queues[_q];
                q.sort((a, b) => a[1] - b[1]);
                // look at what's already in the queue DOMs and compare it to what's in the JSON
                // then generate a optimized list of actions to perform.
                // increases performance and reduces DOM thrashing.
                var actions = syncArr(list.filter(e => !e.classList.contains('waiter-add')).map(e => e.querySelector(".username_text").innerHTML), q.map(e => e[0]));
                actions.forEach(a => {
                    // format of a: ['action', username, (position)]
                    switch(a[0]) {
                        case "delete":
                            selectElmByUsername(a[1], _q) ? selectElmByUsername(a[1], _q).remove() : null;
                            break;
                        case "add":
                            var user = a[1];
                            var data = q.filter(e => e[0] == user)[0][2];
                            var marked = q.filter(e => e[0] == user)[0][3] == "1" ? true : false;
                            if (a[1] == window.username) {
                                window.userdata = data;
                                window.usermarked = marked;
                                addSelf(_q);
                            }
                            else {
                                addToQueue(a[1], data, marked, _q);
                            }
                            break;
                        case "shift":
                            console.log(selectElmByUsername(a[1], _q), list[a[2]]);
                            htmlarray.insertBefore(selectElmByUsername(a[1], _q), list[a[2]]);
                            break;
                    }
                });
                // check if marked has changed for existing users
                q.forEach(e => {
                    var elm = selectElmByUsername(e[0], _q);
                    if (elm != null) {
                        if (e[3] == "1") {
                            elm.classList.add("flashing");
                            // first button will be marked.
                            if (elm.querySelector(".waiterbtn"))
                                elm.querySelector(".waiterbtn").innerHTML = "Unmark";
                        }
                        else {
                            elm.classList.remove("flashing");
                            // first button will be unmarked.
                            if (elm.querySelector(".waiterbtn"))
                                elm.querySelector(".waiterbtn").innerHTML = "Mark";
                        }
                    }
                });
                // if a TA overrides visibility and both the waiter-add/is-self buttons are removed
                // and if window.username is not in the queue, then assume that student is no longer 
                // in room and we can add waiter-add again
                var list = Array.from(document.querySelector(`#queue${_q}`).children);
                if (list.filter(e => e.classList.contains('waiter-add') || e.classList.contains('is-self')).length == 0) {
                    var html = `<div class="waiter waiter-add" onclick="addBtnHandler(event, '${_q}')"><p class="username_text">+</p></div>`;
                    var added = new DOMParser().parseFromString(html, 'text/html').body.children[0];
                    document.querySelector(`#queue${_q}`).appendChild(added);
                }
                // now sync up time
                applyTimeData(_q, q);
            })
        }
        function applyTimeData(q, roomdata) {
            var list = Array.from(document.querySelector(`#queue${q}`).children);
            roomdata.forEach(a => {
                var elm = list.filter(e => e.querySelector(".username_text").innerHTML.split(" ")[0] == a[0])[0];
                var now = Date.now();
                var then = new Date(parseFloat(a[1])*1000);
                var minute = parseInt((now - then) / (60 * 1000));
                var max = 5;
                var maxopacity = 0.7;
                elm.style["background-color"] = `var(--waiter-bg-${minute <= max ? minute : max})`;
                elm.querySelector('.time_text').innerHTML = `${minute < 1 ? "&lt;1" : minute} min`;
            });
        }
        window.onbeforeunload = () => {
            window.disableErrors = true;
        }
        window.onload = async () => {
            clock();
            // initialize if not set
            if (!localStorage.darkmode) {
                localStorage.darkmode = "false";
            }
            if (localStorage.darkmode == "true") {
                document.documentElement.setAttribute("theme", "dark");
            }
            else {
                document.documentElement.setAttribute("theme", "light");
            }
            document.addEventListener('click', (e) => {
                if (e.target.id != "gear" && document.querySelector("#gear").classList.contains("opened")) {
                    document.querySelector("#gear").click();
                }
            }, true);
        }
        function syncArr(_old, _new) {
            var actions = [];
            var diff = _new.filter(x => !_old.includes(x));
            var del = _old.filter(x => !_new.includes(x));
            del.forEach(i => {
                actions.push(['delete', i]);
                _old = _old.filter(x => x != i);
            });
            diff.forEach(i => {
                actions.push(['add', i]);
                _old.push(i);
            });
            _new.forEach((e,i) => {
                if (_old.indexOf(e) != i) {
                    actions.push(['shift', e, i]);
                }
            })
            return actions;
        }
        function selectElmByUsername(username, queue) {
            var list = Array.from(document.querySelector(`#queue${queue}`).children).filter(e => e.querySelector(".username_text").innerHTML.split(" ")[0] == username);
            return list.length > 0 ? list[0] : null;
        }
        function clock() {
            function IntTwoChars(i) {
                return `0${i}`.slice(-2);
            }
            var time = new Date();
            document.querySelector("#time").innerHTML = `${IntTwoChars(time.getHours())}:${IntTwoChars(time.getMinutes())}`;
            setTimeout(clock, 1000);
        }
        function addSelf(queue) {
            var list = Array.from(document.querySelector(`#queue${queue}`).children).filter(e => e.classList.contains('waiter-add'));
            if (list.length > 0) {
                list[0].remove();
            }
            var html = `<div class="waiter is-self ${window.usermarked ? "flashing" : ""}" onclick="addBtnHandler(event, '${queue}')">
                            <p class="username_text">${window.username}</p>
                            <p class="data_text">${window.userdata}</p>
                            <p class="time_text">&lt;1 min</p>
                        </div>`;
            var added = new DOMParser().parseFromString(html, 'text/html').body.children[0];
            document.querySelector(`#queue${queue}`).appendChild(added);
        }
        function delSelf(queue) {
            var list = Array.from(document.querySelector(`#queue${queue}`).children).filter(e => e.classList.contains('is-self'));
            if (list.length > 0) {
                list[0].remove();
            }
            // response will bring back the add button automatically
        }
        function delFromRoomTA(username, queue) {
            fetchAndLimit(`roomd.py/?action=del&room=${window.roomname}&queue=${queue}&username=${username}`);
            var list = Array.from(document.querySelector(`#queue${queue}`).children).filter(e => e.classList.contains('waiter') && e.querySelector('.username_text').innerHTML == username);
            if (list.length > 0) {
                list[0].remove();
            }
        }
        function performOp(action, queue, username=null) {
            try {
                if (window.is_owner && username != null) {
                    if (action == "del")
                        delFromRoomTA(username, queue);
                }
                else {
                    if (action == "add") {
                        var userdata = null;
                        while ((userdata == null) || !/^[a-zA-Z0-9 \_\'\(\)]{1,50}$/.test(userdata)) {
                            var userdata = prompt("Enter text that would allow a TA to identify you in-person or online (eg. station number or Zoom name).  Press Escape/Cancel to close.", window.userdata);
                            if (userdata == null) {
                                window.disableOperations = false;
                                return;
                            }
                        }
                        window.userdata = userdata;
                        fetchAndLimit(`roomd.py/?action=add&room=${window.roomname}&queue=${queue}&waitdata=${userdata}`)
                        .catch(err => {
                            window.disableOperations = false;
                            if (err.includes("Room locked")) {
                                delSelf(queue);
                            }
                        })
                    }
                    else {
                        fetchAndLimit(`roomd.py/?action=del&room=${window.roomname}&queue=${queue}`);
                    }
                    var qlist = document.querySelector(`#queue${queue}`).children;
                    var added = qlist[qlist.length - 1];
                    if (action == "add") {
                        addSelf(queue);
                    }
                    else if (action == "del") {
                        delSelf(queue);
                    }
                }
            }
            catch(err) {
                console.log(`Error occurred while performing ${action} on room ${window.roomname}, queue ${queue}.`);
                console.error(err);
            }
        }
        function addToQueue(username, data, marked, queue) {
            var list = document.querySelector(`#queue${queue}`);
            // do not add duplicates!
            if (Array.from(list.children).map(e => e.querySelector(".username_text").innerHTML).includes(username)) {
                return;
            }
            var owner_buttons = window.is_owner ? `<div class="owner-buttons">
                <button class="btn waiterbtn" onclick='markOrDelUser(event, "mark")'>Mark</button>
                <button class="btn waiterbtn" onclick='markOrDelUser(event, "del")'>Delete</button>
            </div>` : "";
            var time = "&lt;1";
            var parser = new DOMParser();
            var user_data = `<p class="data_text">${data}</p>`;
            var newhtml = parser.parseFromString(`<div class="waiter ${marked ? "flashing" : ""}"><p class="username_text">${username}</p>${user_data}<p class="time_text">${time} min</p>${owner_buttons}</div>`, 'text/html');
            var elm = newhtml.body.children[0];
            console.log("addtoqueue", elm, list.children);
            // has our own entry already been added?  Then add the incoming entry at the end of the list.
            if (Array.from(list.children).filter(e => e.classList.contains("waiter-add")).length > 0)
                list.insertBefore(elm, list.children[list.children.length - 1]);
            else
                list.insertBefore(elm, null);
        }
        function addBtnHandler(event, queue) {
            if (window.disableOperations) return;
            window.disableOperations = true;
            if (event.currentTarget.classList.contains("waiter-add")) {
                // then we're adding a new one
                performOp('add', queue);
            }
            else if (window.is_owner && !event.currentTarget.classList.contains("is-self")) {
                // we are a TA and removing someone else's username, not our own
                performOp('del', queue, event.currentTarget.querySelector('.username_text').innerHTML.split(" ")[0]);
            }
            else if (event.currentTarget.classList.contains("is-self")) {
                // then we're removing an existing one
                performOp('del', queue);
            }
        }
        async function renameQueue(event) {
            if (event.type != "blur")
                return;
            if (!window.is_owner)
                return;
            event.preventDefault();
            var curTarget = event.currentTarget;
            curTarget.innerHTML = curTarget.innerHTML.replace(" ", "");
            curTarget.blur();
            // name was not changed.
            if (curTarget.innerHTML == curTarget.getAttribute("queue")) {
                return;
            }
            if (!/^[a-zA-Z0-9\_]{3,15}$/.test(curTarget.innerHTML)) {
                alert("Queue name must be alphanumeric with optional underscores, be more than 3 characters and less than 16 characters long.");
                curTarget.innerHTML = curTarget.getAttribute("queue");
                return;
            }
            var r = await fetchAndLimit(`roomd.py/?setup=true&action=ren&room=${window.roomname}&queue=${curTarget.getAttribute("queue")}&newqueue=${curTarget.innerHTML}`);
            if (r.status != 200) {
                alert("An error occurred while renaming the queue.  Please try again.");
                curTarget.innerHTML = curTarget.getAttribute("queue");
                return;
            }
            else {
                // response will add back the renamed queue
                curTarget.parentNode.remove();
                // document.querySelector(`#queue${curTarget.getAttribute("queue")}`).remove();
            }
        }
        async function setRoomSubtitle(event) {
            // triggers when focus is shifted away (by pressing Enter or clicking somewhere else)
            if (!window.is_owner)
                return;
            event.preventDefault();
            var curTarget = event.currentTarget;
            curTarget.innerHTML = curTarget.innerHTML.replace(/<br>/g, "");
            curTarget.innerHTML.trim();
            curTarget.blur();
            // name was not changed.
            if (curTarget.innerHTML == curTarget.getAttribute("subtitle")) {
                return;
            }
            // special handling for empty subtitles
            else if ((curTarget.innerHTML == "") || (curTarget.innerHTML == "<br>") || (curTarget.innerHTML == "Add room information...")) {
                curTarget.innerHTML = "Add room information...";
                curTarget.setAttribute("subtitle", "");
                var subtitle = "";
            }
            else {
                if (!/^[a-zA-Z0-9 \_\-]{1,130}$/.test(curTarget.innerHTML)) {
                    alert("Room subtitle can only contain the characters a-z, A-Z, 0-9, spaces, hyphens, and underscores, and must be less than 130 characters long.");
                    curTarget.innerHTML = curTarget.getAttribute("subtitle");
                    return;
                }
                var subtitle = curTarget.innerHTML;
            }
            var r = await fetchAndLimit(`roomd.py/?setup=true&action=setsub&room=${window.roomname}&subtitle=${subtitle}`);
            if (r.status != 200) {
                alert("An error occurred while setting the room description.  Please try again.");
                curTarget.innerHTML = curTarget.getAttribute("subtitle");
            }
            else {
                curTarget.classList.toggle("textadded", curTarget.innerHTML != "Add room information...");
                curTarget.setAttribute("subtitle", subtitle);
            }
        }
        function addRoom(room, subtitle) {
            // this application will not do multiple rooms.  remove all rooms first
            var parser = new DOMParser();
            if (subtitle == '' && !window.is_owner) {
                var subtitle_p = '';
            }
            else if (subtitle == '') {
                var subtitle_p = `<p class="roomsubtitle" contenteditable subtitle="">Add room information...</p>`;
            }
            else {
                var style = window.is_owner ? "" : "style='cursor:default'";
                var edit = window.is_owner ? "contenteditable" : "";
                var subtitle_p = `<p class="roomsubtitle textadded" ${style} ${edit} subtitle=${subtitle}>${subtitle}</p>`;
            }
            var newhtml = parser.parseFromString(`
            <div class="roomtop">
                <p class="roomtitle">Room ${room}</p>
                <div class="helpdiv row">${subtitle_p}</div>
            </div>`, 'text/html');
            var elm = newhtml.body.children[0];
            document.querySelector(`#rooms`).insertBefore(elm, document.querySelector("#queueadddiv"));
            if (window.is_owner) {
                document.querySelector(".roomsubtitle").addEventListener('blur', setRoomSubtitle);
                document.querySelector(".roomsubtitle").addEventListener('keydown', (event)=>{if(['Enter','Escape'].includes(event.key)){event.preventDefault();event.currentTarget.blur()}});
            }
        }
        function clearQueue(queue) {
            if (!window.is_owner) {
                alert("You are not authorized to clear this queue.  Unauthorized requests will be logged.");
                return;
            }
            fetchAndLimit(`roomd.py/?setup=true&action=clear&room=${window.roomname}&queue=${queue}`);
        }
        function markOrDelUser(event, action='mark') {
            if (!window.is_owner) {
                alert("You are not authorized to perform this action.  Unauthorized requests will be logged.");
                return;
            }
            var queue = event.currentTarget.parentNode.parentNode.parentNode.id.slice(5);
            var username = event.currentTarget.parentNode.parentNode.querySelector(".username_text").innerHTML;
            if (action == 'mark') {
                // send a "mark" signal for this user.  if already marked, will be unmarked.
                fetchAndLimit(`roomd.py/?setup=true&action=mark&room=${window.roomname}&queue=${queue}&username=${username}`);
            }
            else {
                // delete user from queue. 
                performOp('del', queue, username);
            }
        }
        function addQueue(queue) {
            var parser = new DOMParser();
            var newhtml = parser.parseFromString(`<div style="width: 100%; display: flex; flex-direction: row; justify-content: space-between; align-items: center">
            <p class="queuetitle" ${window.is_owner ? "" : "style='cursor:default'"}" onblur="renameQueue(event)" onkeydown="if(['Enter','Escape'].includes(event.key)){event.preventDefault();event.currentTarget.blur()}" queue="${queue}" ${window.is_owner ? "contenteditable" : ""}>${queue}</p>
            ${window.is_owner ? ('<button class="btn clearbtn" style="display: flex;" onclick=\'clearQueue("' + queue + '")\'>Clear</button>') : ""}
            </div>
            <div id="queue${queue}" class="queue"></div>`, 'text/html');
            document.querySelector(".roomtop").appendChild(newhtml.body.children[0]);
            // JS madness - appendChild REMOVES THE CHILD FROM NEWHTML!
            document.querySelector(".roomtop").appendChild(newhtml.body.children[0]);
        }
        // for later theme changes
        function switchTheme() {
            if (localStorage.darkmode == "true") {
                localStorage.darkmode = "false";
            }
            else {
                localStorage.darkmode = "true";
            }
            document.documentElement.setAttribute("theme", localStorage.darkmode == "true" ? "dark" : "light");
        }
        async function toggleRoomLock() {
            try {
                var action = document.getElementById("toggleroomlock").innerHTML == "Lock Room" ? "lock" : "unlock";
                var response = await fetchAndLimit(`roomd.py?setup=true&action=${action}&room=` + window.roomname);
                if (response.status != 200) {
                    alert("An error occurred while toggling the room lock.  Error: " + await response.text());
                    return;
                }
                else {
                    var locked = action == "lock";
                    window.roomlocked = locked;
                    alert("Successfully toggled room lock.  Room is now " + (locked ? "locked" : "unlocked") + ".  " +
                          "Users can " + (locked ? "no longer" : "now") + " add themselves to queues.");
                }
                document.getElementById("toggleroomlock").innerHTML = locked ? "Unlock Room" : "Lock Room";
            }
            catch(err) {
                alert("An error occurred while toggling the room lock: " + err.toString());
                console.error(err);
            }
        }
        async function modRoomOwners(action='add') {
            var owners = null;
            while (owners == null) {
                var owners = prompt("Enter a comma-separated list of usernames to " + (action == "add" ? "add as" : "delete from") + " room owners. (eg. user1, user2, user3)\n" + 
                                    "You can also enter an empty string to get the current list of owners.");
                if (owners == null) {
                    return;
                }
                owners = owners.replace(/ /g, "");
                // mistake typing usernames
                try { owners = owners.split(","); }
                catch(err) { owners = null; }
                if (owners != "" && !/^[a-zA-Z0-9\-, /]{3,300}$/.test(owners.join(","))) {
                    alert("Usernames must be alphanumeric with optional hyphens, be more than 3 characters and less than 16 characters long.");
                    owners = null;
                }
            }
            try {
                var _action = action == 'add' ? '' : 'del';
                var response = await fetchAndLimit(`roomd.py?setup=true&action=${_action}own&room=` + window.roomname + '&newusers=' + owners.join(","));
                if (response.status != 200) {
                    alert("An error occurred while modifying the owner list.  Error: " + await response.text());
                    return;
                }
                else {
                    var newowners = await response.text();
                    newowners = newowners.replace(/"/g, "").replace(/'/g, "");
                    if (owners == "") {
                        alert("The current list of owners for this room is " + newowners + ".");
                    }
                    else {
                        alert("Successfully modified owner list.  List of owners for this room is: " + newowners + ".");
                    }
                }
            }
            catch(err) {
                alert("An error occurred while modifying owners: " + err.toString());
                console.error(err);
            }
        }
        // set up gear collapsible
        var gear = document.getElementById("gear");
        gear.addEventListener('click', function(event) {
            event.currentTarget.classList.toggle("opened");
            document.querySelector(".collapsible").classList.toggle("opened");
        });
        // set up help overlay
        var help = document.getElementById("help");
        help.addEventListener('click', function(event) {
            event.currentTarget.classList.toggle("opened");
            if (event.currentTarget.classList.contains("opened"))
                event.currentTarget.innerHTML = "‚ùå";
            else
                event.currentTarget.innerHTML = "‚ùì";
            document.querySelector(".tutorialoverlay").classList.toggle("opened");
        });
        // permit only allowed characters
        document.querySelector("#createroom").addEventListener('keydown', (e)=>{if((!e.ctrlKey) && !/^[A-Z0-9]$/.test(e.key)){e.preventDefault()}});
        document.querySelector("#joinroom").addEventListener('keydown', (e)=>{if((!e.ctrlKey) && !/^[A-Z0-9]$/.test(e.key)){e.preventDefault()}});
        // Escape detector for body
        document.body.addEventListener('keydown', (e) => {
            if ((e.key == 'Escape') && document.querySelector('#help').classList.contains('opened')) {
	            document.querySelector('#help').click();
            }
        });
        document.getElementById("joinroom").addEventListener('keydown', (e) => {
            if (e.key == 'Enter') {
                document.querySelector('#joinroombtn').click();
            }
        });
        document.getElementById("createroom").addEventListener('keydown', (e) => {
            if (e.key == 'Enter') {
                document.querySelector('#createroombtn').click();
            }
        });
    </script>
</body>
<!-- Designed and deployed by Niraj Menon, 2023. -->
</html>
